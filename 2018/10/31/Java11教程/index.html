<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><title>Java 11 教程（译）</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css"><link rel="stylesheet" href="/css/progressjs.css"><script src="/js/progress.js"></script><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-160006603-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-160006603-1');
</script><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"></head><body><script>if (document.readyState == 'loading') {
  progressJs().start()
}
document.addEventListener('readystatechange', (event) => {
  if (document.readyState == 'interactive') {
    progressJs().set(50)
  }
  if (document.readyState == 'complete') {
    progressJs().end()
  }
});
</script><div><div class="inner"><h2>Java 11 教程（译）</h2><p>Java 11已经发布，很多人还在使用Java 8。这篇教程讲述一些重要的语言特性和API。</p>
<h3 id="局部变量类型推断"><a href="#局部变量类型推断" class="headerlink" title="局部变量类型推断"></a>局部变量类型推断</h3><p>局部变量指在方法体内声明的变量。Java10就已经引进一个新的关键字var，用于代替在声明局部变量时候的类型声明。</p>
<p>在Java 10之前，你必须这样声明一个变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String text = <span class="string">"Hello Java 9"</span>;</span><br></pre></td></tr></table></figure>
<p>现在你可以使用var代替String。编译器会自动从变量的赋值推断出正确的类型。如文本的类型为String：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"Hello Java 10"</span>;</span><br></pre></td></tr></table></figure>
<p>使用var声明的变量仍然是静态变量，不可以在声明后赋值为其它类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"Hello Java11"</span>;</span><br><span class="line">text = <span class="number">23</span>;  <span class="comment">// 编译错误，不兼容的类型</span></span><br></pre></td></tr></table></figure>
<p>同样可以使用final声明变量为常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">var</span> text = <span class="string">"Banana"</span>;</span><br><span class="line">text = <span class="string">"Joe"</span>;   <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure>
<p>当然，在编译器无法推断出类型的场景下，不可以使用var，比如这些情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> nothing = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">var</span> lamdba = () -&gt; System.out.println(<span class="string">"Pity!"</span>);</span><br><span class="line"><span class="keyword">var</span> method = <span class="keyword">this</span>::someMethod;</span><br></pre></td></tr></table></figure>
<p>当变量声明包含泛型时，var的优势尤为突出，下面的示例就用var来代替冗长的Map&lt;String, List<integer>&gt;：</integer></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myList = <span class="keyword">new</span> ArrayList&lt;Map&lt;String, List&lt;Integer&gt;&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> current : myList) &#123;</span><br><span class="line">    <span class="comment">// current 的类型会被推断为 Map&lt;String, List&lt;Integer&gt;&gt;</span></span><br><span class="line">    System.out.println(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 11的var关键字同样支持在lamdba表达式的参数中使用，并且支持为这些参数添加注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Predicate&lt;String&gt; predicate = (<span class="meta">@Nullable</span> <span class="keyword">var</span> a) -&gt; <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小技巧：在Intellij IDEA中按住CTRL键可以查看变量的推断类型。</p>
</blockquote>
<h2 id="HTTP-Client"><a href="#HTTP-Client" class="headerlink" title="HTTP Client"></a>HTTP Client</h2><p>从Java 9开始引进试用新的API HttpClient，用于处理HTTP请求。现在Java 11将其标准化，我们可以从模块java.net中获取使用。</p>
<p>新的HttpClient在同步和异步场景下都可以使用。同步请求会阻塞线程，直到获取到响应。BodyHandlers定义了响应数据的类型（如String、Byte[]、File）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> request = HttpRequest.newBuilder()</span><br><span class="line">        .uri(URI.create(<span class="string">"https://blog.smallyu.net"</span>))</span><br><span class="line">        .GET()</span><br><span class="line">        .build();</span><br><span class="line"><span class="keyword">var</span> client = HttpClient.newHttpClient();</span><br><span class="line"><span class="keyword">var</span> response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">System.out.println(response.body());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记得在module-info.java中导入java.net.http模块</span></span><br></pre></td></tr></table></figure>
<p>同样可以使用异步的方式实现请求，调用sendAsync方法并不会阻塞当前线程，它会构建异步操作流，在接收到响应后执行相应操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> request = HttpRequest.newBuilder()</span><br><span class="line">        .uri(URI.create(<span class="string">"https://blog.smallyu.net"</span>))</span><br><span class="line">        .build();</span><br><span class="line"><span class="keyword">var</span> client = HttpClient.newHttpClient();</span><br><span class="line">client.sendAsync(request, HttpResponse.BodyHandlers.ofString())</span><br><span class="line">        .thenApply(HttpResponse::body)</span><br><span class="line">        .thenAccept(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程睡眠，防止在返回响应前当前线程就结束</span></span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>.GET()方法会作为默认的请求方式。</p>
</blockquote>
<p>下一个示例通过POST方式发送请求到指定URL。与BodyHandlers相似，使用BodyPublishers定义要发送的数据类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> request = HttpRequest.newBuilder()</span><br><span class="line">        .uri(URI.create(<span class="string">"https://postman-echo.com/post"</span>))</span><br><span class="line">        .header(<span class="string">"Content-Type"</span>, <span class="string">"text/plain"</span>)</span><br><span class="line">        .POST(HttpRequest.BodyPublishers.ofString(<span class="string">"Hi there!"</span>))</span><br><span class="line">        .build();</span><br><span class="line"><span class="keyword">var</span> client = HttpClient.newHttpClient();</span><br><span class="line"><span class="keyword">var</span> response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">System.out.println(response.statusCode());      <span class="comment">// 200</span></span><br></pre></td></tr></table></figure>
<p>最后一个示例演示了如何使用BASIC-AUTH执行权限验证：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> request = HttpRequest.newBuilder()</span><br><span class="line">    .uri(URI.create(<span class="string">"https://postman-echo.com/basic-auth"</span>))</span><br><span class="line">    .build();</span><br><span class="line"><span class="keyword">var</span> client = HttpClient.newBuilder()</span><br><span class="line">    .authenticator(<span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> PasswordAuthentication <span class="title">getPasswordAuthentication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PasswordAuthentication(<span class="string">"postman"</span>, <span class="string">"password"</span>.toCharArray());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .build();</span><br><span class="line"><span class="keyword">var</span> response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">System.out.println(response.statusCode());      <span class="comment">// 200</span></span><br></pre></td></tr></table></figure>
<h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><p>集合框架如List、Set和Map都增加了新的方法。List.of方法根据给定参数创建一个不可变列表，List.copyOf创建一个已存在列表的副本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = List.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>);</span><br><span class="line"><span class="keyword">var</span> copy = List.copyOf(list);</span><br><span class="line">System.out.println(list == copy);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>因为列表已经不可变，所以拷贝出的列表和原列表是同一实例。如果拷贝了一个可变列表，拷贝出的列表会是一个新的实例，不会对原列表产生副作用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">var</span> copy = List.copyOf(list);</span><br><span class="line">System.out.println(list == copy);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>创建不可变映射不必自己创建映射实体，只需要将key和value交替传入作为参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = Map.of(<span class="string">"A"</span>, <span class="number">1</span>, <span class="string">"B"</span>, <span class="number">2</span>);</span><br><span class="line">System.out.println(map);    <span class="comment">// &#123;B=2, A=1&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Java 11中的不可变列表和旧版本的列表使用相同的接口，但是如果你对不可变列表进行修改，如添加或移除元素，程序会抛出java.lang.UnsupportedOperationException异常。幸运的是，当你试图修改不可变列表，Intellij IDEA会检查并给出警告。</p>
</blockquote>
<h3 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h3><p>Streams从Java 8开始引进，现在新增了三个方法。Stream.ofNullable从单个元素构建流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.ofNullable(<span class="keyword">null</span>)</span><br><span class="line">    .count()   <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>dropWhile和takeWhile方法都是用于放弃流中的一些元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    .dropWhile(n -&gt; n &lt; <span class="number">3</span>)</span><br><span class="line">    .collect(Collectors.toList());  <span class="comment">// [3, 2, 1]</span></span><br><span class="line"></span><br><span class="line">Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    .takeWhile(n -&gt; n &lt; <span class="number">3</span>)</span><br><span class="line">    .collect(Collectors.toList());  <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>String类也新增了一些方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">" "</span>.isBlank();                <span class="comment">// true</span></span><br><span class="line"><span class="string">" Foo Bar "</span>.strip();          <span class="comment">// "Foo Bar"</span></span><br><span class="line"><span class="string">" Foo Bar "</span>.stripTrailing();  <span class="comment">// " Foo Bar"</span></span><br><span class="line"><span class="string">" Foo Bar "</span>.stripLeading();   <span class="comment">// "Foo Bar "</span></span><br><span class="line"><span class="string">"Java"</span>.repeat(<span class="number">3</span>);             <span class="comment">// "JavaJavaJava"</span></span><br><span class="line"><span class="string">"A\nB\nC"</span>.lines().count();    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h3 id="其他JVM特性"><a href="#其他JVM特性" class="headerlink" title="其他JVM特性"></a>其他JVM特性</h3><p>Java 11包含许多新特性，以上只提及冰山一角，权作抛砖引玉，更多内容等待你探索……</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://winterbe.com/posts/2018/09/24/java-11-tutorial/" target="_blank" rel="noopener">Java 11 Tutorial</a></li>
</ul>
<div class="align-right"><span>2018-10-31 10:20</span><span> 创建</span></div><div class="align-right"><span>2020-03-15 17:29</span><span> 更新</span></div></div></div></body></html>