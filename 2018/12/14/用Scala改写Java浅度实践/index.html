<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><title>用Scala改写Java浅度实践</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css"><link rel="stylesheet" href="/css/progressjs.css"><script src="/js/progress.js"></script><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-160006603-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-160006603-1');
</script><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"></head><body><script>if (document.readyState == 'loading') {
  progressJs().start()
}
document.addEventListener('readystatechange', (event) => {
  if (document.readyState == 'interactive') {
    progressJs().set(50)
  }
  if (document.readyState == 'complete') {
    progressJs().end()
  }
});
</script><div><div class="inner"><h2>用Scala改写Java浅度实践</h2><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>想要用Java实现Markdown解析器，目前只完成了多级标题的解析。其实也就是正则匹配之后替换掉相应内容，程序暂时比较简单，大致流程如下：</p>
<p><img src="mainProcess.png" alt="main process"></p>
<h3 id="改写"><a href="#改写" class="headerlink" title="改写"></a>改写</h3><p>按照同样的流程，用Scala来实现该功能，之后也将使用Scala继续完成开发。首先读取文件内容，IO操作参考《Scala Cookbook》，只需一行代码即可：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> srcLines = <span class="type">Source</span>.fromFile(srcFile).getLines().toList</span><br></pre></td></tr></table></figure>
<p>与冗长的Java相比，Scala确实精简了不少。这是之前使用Java读取文件封装的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 读取文件内容</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> src 读取文件路径</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 读取文件内容</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readFile</span><span class="params">(String src)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    StringBuffer content = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    InputStream is = <span class="keyword">null</span>;</span><br><span class="line">    BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    is = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">    reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line"></span><br><span class="line">    String line = reader.readLine();</span><br><span class="line">    <span class="keyword">while</span> (line != <span class="keyword">null</span>) &#123;</span><br><span class="line">        content.append(line);</span><br><span class="line">        content.append(<span class="string">"\n"</span>);</span><br><span class="line">        line = reader.readLine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">        is.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> content.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于Scala版本将字符串改为列表操作的原因在于，Scala和Java在使用正则匹配替换的API上有差异。Java使用Matcher对象进行迭代，Matcher对象拥有查找、替换等方法：</p>
<p><img src="replaceProcess.png" alt="replace process"></p>
<p>而Scala的Regex对象虽然拥有findAllMatchIn、replaceAllIn等方法，但在find中的对象仅用于查找，replace方法中又无法定位匹配项的内容。因此在Scala中，将文件读入列表，使用如下方式带索引遍历文本内容：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span>.range(<span class="number">0</span>, srcLines.size).foreach(index =&gt; &#123;</span><br><span class="line">  srcLines = srcLines.updated(index, regexReplace)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>无论是否含有匹配项，循环内都对列表执行一次updated，更新原内容为正则替换后的内容。这样做可能稍微欠妥，关于性能问题将持续关注并整改。可以看到的是，Scala的程序思想与Java典型的OOP确实存在些许差异。</p>
<p>最后关于文件写入，SDK中没有提供专门的操作对象，可使用JDK中的PrintWriter：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> pw = <span class="keyword">new</span> <span class="type">PrintWriter</span>(<span class="keyword">new</span> <span class="type">File</span>(outFile))</span><br><span class="line">pw.write(outString)</span><br><span class="line">pw.close()</span><br></pre></td></tr></table></figure>
<h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>“Scala是一门会伴随开发者成长的语言”，我将用它完成我的毕业设计。</p>
<div class="align-right"><span>2018-12-14 12:36</span><span> 创建</span></div><div class="align-right"><span>2020-03-15 17:29</span><span> 更新</span></div></div></div></body></html>