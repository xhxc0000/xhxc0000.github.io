<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><title>Rust基础语法概述</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css"><link rel="stylesheet" href="/css/progressjs.css"><script src="/js/progress.js"></script><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-160006603-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-160006603-1');
</script><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"></head><body><script>if (document.readyState == 'loading') {
  progressJs().start()
}
document.addEventListener('readystatechange', (event) => {
  if (document.readyState == 'interactive') {
    progressJs().set(50)
  }
  if (document.readyState == 'complete') {
    progressJs().end()
  }
});
</script><div><div class="inner"><h2>Rust基础语法概述</h2><p>Rust是复杂度和应用场景都对标C++的语言，一起学习吧！</p>
<p>最近，我开始思考像本文这样类型的内容算什么，编程语言的教程？内容不全面；对语言的评价？够不着；学习笔记？如果是，那绝非我本意。我倾向于认为这是一个探索的过程，无论对于我自己还是对于别人，我希望可以表现出来的是，你看，新的编程语言没什么神秘的，它如此简单！有的程序员终其一生，都将某种语言作为自己职业头衔的前缀，“Java程序员”或是“后端开发”，我们该跳出这种怪圈。</p>
<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>Rust必须以<code>;</code>结尾。</p>
<h3 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h3><p>Rust使用<code>let</code>定义常量，使用<code>let mut</code>定义变量。这样的写法可能稍微有点奇怪：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> y = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, y);</span><br><span class="line"></span><br><span class="line">  y = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不同于其他语言的是，Rust允许在同一作用域中多次声明同一常量。也就是说，Rust里的常量虽然不可以被第二次赋值，但是同一常量名可以被多次定义。我们虽然能在系统层面明白常量和变量的区别，但是写法上稍微有点容易引起混淆。我多次给同一组符号赋值，这个符号不就是变量吗？</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个有点奇怪的地方是，Rust的变量不允许重复定义。我们无法推测语言设计者的初衷，这明显不是为了允许重复定义而允许。也许，Rust中只存在常量，<code>mut</code>关键字的作用就是给常量一个可以被多次赋值的接口。没有mut，常量就是个常量，有了mut，常量就有了获得新值的“入口”。至于变量重复定义的问题，要啥自行车？</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// warning: variable does not need to be mutable</span></span><br></pre></td></tr></table></figure>
<h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><p>Rust的条件部分不需要写小括号，和Go语言一样。谁先谁后呢？</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> number = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> number == <span class="number">1</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"1"</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> number == <span class="number">2</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"2"</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"3"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于if语句本身是一个表达式，所以也可以嵌套进赋值语句中，实现类似其他语言三目运算符的功能。（Rust是强类型的语言，所以赋值类型必须一致。）</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> number = <span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="number">4</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与Go语言简洁的多功能for循环相比，Rust支持多种类型的循环：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  <span class="keyword">for</span> item <span class="keyword">in</span> a.iter() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数与值的传递"><a href="#函数与值的传递" class="headerlink" title="函数与值的传递"></a>函数与值的传递</h3><p>Rust似乎不存在值传递与引用传递的区别，因为Rust中全都是引用传递，或者分类为常量的传递与变量的传递。对比Java中字符串的创建，Rust中创建字符串也可以使用“声明对象”的方式：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="comment">// 常量传递</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="built_in">String</span>::from(<span class="string">"a"</span>);</span><br><span class="line">  testa(&amp;a);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 变量传递</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> b = <span class="built_in">String</span>::from(<span class="string">"b"</span>);</span><br><span class="line">  testb(&amp;<span class="keyword">mut</span> b);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">testa</span></span>(a: &amp;<span class="built_in">String</span>) &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">testb</span></span>(b: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">  b.push_str(<span class="string">" b"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数当然也是可以有返回值的，Rust中函数的返回值用<code>-&gt;</code>定义类型，默认将函数最后一行的值作为返回值，也可以手动return提前结束函数流程。需要注意的是，在最后一行用来作为返回值的表达式，记得不要加封号……</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> a = test();</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, a);</span><br><span class="line"></span><br><span class="line">  a = test2();</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test</span></span>() -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">  <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test2</span></span>() -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>结构体的基本用法比较常规，没有<code>new</code>关键字，直接“实例化”就可以使用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span> &#123;</span><br><span class="line">  a: <span class="built_in">String</span>,</span><br><span class="line">  b: <span class="built_in">i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> t = Foo &#123;</span><br><span class="line">    a: <span class="built_in">String</span>::from(<span class="string">"a"</span>),</span><br><span class="line">    b: <span class="number">1</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;, &#123;&#125;"</span>, t.a, t.b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样可以给结构体添加方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span> &#123;</span><br><span class="line">  a: <span class="built_in">String</span>,</span><br><span class="line">  b: <span class="built_in">i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Foo &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">test</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.b + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> t = Foo &#123;</span><br><span class="line">    a: <span class="built_in">String</span>::from(<span class="string">"a"</span>),</span><br><span class="line">    b: <span class="number">1</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;, &#123;&#125;, &#123;&#125;"</span>, t.a, t.b, t.test());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a, 1, 2</span></span><br></pre></td></tr></table></figure>
<h3 id="列表与模式匹配"><a href="#列表与模式匹配" class="headerlink" title="列表与模式匹配"></a>列表与模式匹配</h3><p>下面的例子创建了包含3个元素的向量，然后将第0个元素赋值给常量one。之后使用模式匹配判断列表的第0个元素是否等于one的值，如果相等则输出字符串”one”，否则为”none”。Rust的模式匹配中，Some()和None都是内置的关键字：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> one = &amp;v[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, one);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">match</span> v.get(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="literal">Some</span>(one) =&gt; <span class="built_in">println!</span>(<span class="string">"one"</span>),</span><br><span class="line">    <span class="literal">Some</span>(<span class="number">2</span>) =&gt; <span class="built_in">println!</span>(<span class="string">"two"</span>),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">"none"</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>panic函数用于抛出异常：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="built_in">panic!</span>(<span class="string">"new Exception"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// thread 'main' panicked at 'new Exception', test.rs:4:3</span></span><br><span class="line"><span class="comment">// note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.</span></span><br></pre></td></tr></table></figure>
<p>针对错误处理，Rust提供了两个简写的方法，用于便捷的处理错误信息。unwrap()函数会自动抛出panic，如果不使用unwrap()，程序则会跳过发生panic的代码。这在某种程度上与Java的异常处理逻辑相反，因为Java如果不对异常进行处理，程序就无法继续运行。而Rust如果使用unwrap()对panic进行处理，程序将不再继续执行，同时打印出错误信息。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"a"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> f2 = File::open(<span class="string">"hello.txt"</span>).unwrap();</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"b"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Os &#123; code: 2, kind: NotFound, message: "系统找不到指定的文件。" &#125;', src\libcore\result.rs:999:5</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>另一个简写的方法是expect()，可用于替代unwrap()。它与unwrap()的区别在于，unwrap()使用系统内置的panic信息，而expect()可以传入参数作为panic的错误信息。仅此而已。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>).expect(<span class="string">"Failed to open hello.txt"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread 'main' panicked at 'Failed to open hello.txt: ...</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>Rust中的Lambda表达式使用<code>|</code>作为入参的界定符，即使用<code>||</code>来代替<code>()</code>。此外Lambda的公用和其它语言是相同的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> test = |num| &#123;</span><br><span class="line">    num == <span class="number">1</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;, &#123;&#125;"</span>, test(<span class="number">1</span>), test(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// true, false</span></span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>Rust的语言特性远不止此，尤其是Rust与众不同的内存管理机制，以及让Rust新手得其门不得其道的概念”ownership”，都需要我们不断前行。</p>
<div class="align-right"><span>2019-08-19 22:12</span><span> 创建</span></div><div class="align-right"><span>2020-03-15 17:29</span><span> 更新</span></div></div></div></body></html>