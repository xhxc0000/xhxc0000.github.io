<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><title>Go语言基本语法</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css"><link rel="stylesheet" href="/css/progressjs.css"><script src="/js/progress.js"></script><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-160006603-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-160006603-1');
</script><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"></head><body><script>if (document.readyState == 'loading') {
  progressJs().start()
}
document.addEventListener('readystatechange', (event) => {
  if (document.readyState == 'interactive') {
    progressJs().set(50)
  }
  if (document.readyState == 'complete') {
    progressJs().end()
  }
});
</script><div><div class="inner"><h2>Go语言基本语法</h2><p>Go语言虽然在语言设计上不被王垠看好，但它如此简洁的代码结构确实让人着迷。</p>
<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>Go语言语句结尾不需要<code>;</code>。</p>
<h3 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h3><p>使用<code>var</code>声明变量。当变量需要初始化时，可以使用赋值符号<code>:=</code>代替<code>=</code>以省略var关键字。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="string">"golang"</span>  <span class="comment">// 编译器自动推断类型</span></span><br><span class="line">d := <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>与C语言或Java不同，Go语言的类型声明在变量右侧。需要注意的是，如果程序中声明的变量未经使用，程序将无法通过编译。Go语言是一种工程化的语言，因此它的一些特性让人感觉不可理喻，但又会在实际工程中提高效益。</p>
<p>Go语言的变量赋值支持一些炫酷的写法，比如要交换变量x和y的值，可以使用这种违反直觉的写法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x, y = y, x</span><br></pre></td></tr></table></figure>
<p>Go语言中使用<code>const</code>定义常量，<code>true</code>、<code>false</code>和<code>iota</code>是预定义常量。其中iota稍显特殊，iota会在每一个const关键字出现时重置为0，然后在下一次const出现前，每出现一次iota，iota的值加1。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="literal">iota</span>   <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="literal">iota</span>   <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  c = <span class="literal">iota</span>       <span class="comment">// 0</span></span><br><span class="line">  d = <span class="literal">iota</span>       <span class="comment">// 1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="数组和切片"><a href="#数组和切片" class="headerlink" title="数组和切片"></a>数组和切片</h3><p>声明一个元素个数为3的数组，并初始化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">array := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">array[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">fmt.Println(array)</span><br></pre></td></tr></table></figure>
<p>和其他语言一样，Go语言在声明数组后并不能改变数组的大小。所以Go语言提供了像Python一样的切片。切片可以从数组中产生，也可以使用make()函数新建。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">array := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">slice1 := array[:<span class="number">2</span>]       <span class="comment">// 从数组中创建</span></span><br><span class="line"></span><br><span class="line">slice2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>)  <span class="comment">// 直接创建</span></span><br><span class="line"></span><br><span class="line">fmt.Println(slice1)       <span class="comment">// [0 1]</span></span><br><span class="line">fmt.Println(slice2)       <span class="comment">// [0 0 0]</span></span><br></pre></td></tr></table></figure>
<p>除切片外，映射也是使用make函数创建，映射的类型全称是<code>var myMap map[string] int</code>，意为声明变量myMap，key为string，value为int。</p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>Go语言允许if-else语句的条件表达式不加小括号，当然加上也无妨。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> a == <span class="number">1</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选择语句的条件表达式同样不需要小括号，另外也不需要break，其他匹配项并不会执行，这一点和Scala相同。对选择语句的优化貌似已经是不约而同的做法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环结构的条件表达式依然不需要小括号。Go语言只支持for循环。同时对无限循环的场景也做了优化，不再需要for(;;)的写法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Go语言诞生自C语言的派系，因此Go语言从一开始就不是OOP或FP的语言，没有类、对象等概念。函数是程序中的一等公民。和C语言相同，（main包下的）main函数是整个程序的入口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b, a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  x, y := add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="built_in">print</span>(x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go语言的语句简洁高效，函数名后的第一个括号为入参，第二个括号是出参。函数支持多返回值。如果参数类型相同，可以将类型声明合并到一起，如<code>(a, b int)</code>。</p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>刚才提到Go语言没有类、对象等概念，但是Go语言有类似C语言的结构体，并且能力强大。这里定义一个Person结构体，包含两个属性name和age，并为Person添加一个方法getInfo，用于输出Person对象的信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="keyword">string</span></span><br><span class="line">  age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">getInfo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(p.name, p.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  smallyu := <span class="built_in">new</span>(Person)</span><br><span class="line">  smallyu.name = <span class="string">"smallyu"</span></span><br><span class="line">  smallyu.age = <span class="number">1</span></span><br><span class="line">  smallyu.getInfo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用OOP的思想理解这样的程序并不违和。除了结构体，Go语言还保留有指针的概念。Java程序员对指针可能稍感陌生，关于指针在结构体方法中的应用，可以通过一个简单的例子来了解：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">setName</span><span class="params">()</span></span> &#123;</span><br><span class="line">  p.name = <span class="string">"set name"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">setName2</span><span class="params">()</span></span> &#123;</span><br><span class="line">  p.name = <span class="string">"set name"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  smallyu := &amp;Person&#123;<span class="string">"smallyu"</span>&#125;</span><br><span class="line">  smallyu.setName()</span><br><span class="line">  fmt.Println(smallyu)        <span class="comment">// &amp;&#123;smallyu&#125;</span></span><br><span class="line"></span><br><span class="line">  bigyu := &amp;Person&#123;<span class="string">"bigyu"</span>&#125;</span><br><span class="line">  bigyu.setName2()</span><br><span class="line">  fmt.Println(bigyu)          <span class="comment">// &amp;&#123;set name&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用值类型定义的结构体方法，入参为形参；使用引用类型定义的结构体方法，入参为实参。<code>&amp;{}</code>是初始化对象的方法之一，等同于<code>new()</code>。</p>
<h3 id="匿名结合"><a href="#匿名结合" class="headerlink" title="匿名结合"></a>匿名结合</h3><p>Go语言中匿名结合的概念，相当于OOP语言的继承。一个结构体可以继承另一个结构体的属性和方法，大致是这样。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Father <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Father)</span> <span class="title">getName</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(f.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Son <span class="keyword">struct</span> &#123;</span><br><span class="line">  Father</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  smallyu := &amp;Son&#123;&#125;</span><br><span class="line">  smallyu.name = <span class="string">"smallyu"</span></span><br><span class="line">  smallyu.getName()       <span class="comment">// smallyu</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Son并没有定义name属性，也没有定义getName()方法，它们均继承自Father。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>Go语言的接口是非侵入式的，结构体只要实现了接口中的所有方法，程序就会认为结构体实现了该接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IPerson <span class="keyword">interface</span> &#123;</span><br><span class="line">  getName()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">getName</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> smallyu IPerson = &amp;Person&#123;<span class="string">"smallyu"</span>&#125;</span><br><span class="line">  smallyu.getName()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>使用协程的关键字是<code>go</code>，从命名就能看出协程对于Go语言的重要性、协程是轻量级的线程，启动一个协程非常简单：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="built_in">println</span>(msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  f(<span class="string">"直接调用方法"</span>)</span><br><span class="line">  <span class="keyword">go</span> f(<span class="string">"协程调用方法"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，你会发现程序只打印出”直接调用方法”几个字。这种情况是不是似曾相识？go启用了另一个”线程”来打印消息，而main线程早已结束。在程序末尾加上<code>fmt.Scanln()</code>阻止main线程的结束，就能看到全部的打印内容。</p>
<h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>通道即协程之间相互通信的通道。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  message := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    message &lt;- <span class="string">"ping"</span></span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  msg := &lt;-message</span><br><span class="line">  <span class="built_in">println</span>(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>make函数返回一个chan string类型的通道，在匿名函数中将字符串”ping”传入通道，之后将通道中的数据输出到变量msg，最后打印出msg的值为”ping”。</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>Go语言在错误处理部分有两个函数较为常用，panic函数和defer函数。panic函数会打印错误消息，并终止整个程序的执行，类似Java的Throw Exception；defer函数会在当前上下文环境执行结束前再执行，类似try catch后的finally；panic函数虽然会终止整个程序，但不会终止defer函数的执行，可以将defer函数用于打印日志。这是一个简单的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">"beginning"</span>)</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"defer"</span>)</span><br><span class="line">  &#125; ()</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">"middle"</span>)</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">"panic"</span>)</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">"ending"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来分析一下程序的执行结果。首先beginning被打印；然后遇到defer，暂不打印；middle在defer之前被打印；遇到panic，程序将终止，打印defer和panic。</p>
<p>这里要注意，defer是在程序结束前执行，而不是在其他语句结束后执行，这是有区别的。就像这里，panic函数引起了当前程序的结束，所以defer会在panic函数前执行，而不是panic后。程序的执行结果如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">beginning</span><br><span class="line">middle</span><br><span class="line"><span class="keyword">defer</span></span><br><span class="line"><span class="built_in">panic</span>: <span class="built_in">panic</span></span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [running]:</span><br><span class="line">main.main()</span><br><span class="line">	D:/<span class="keyword">go</span>/src/awesomeProject/main.<span class="keyword">go</span>:<span class="number">12</span> +<span class="number">0x7f</span></span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>除此之外Go语言还有很多语言特性，也提供了非常多实用的工具包。Go语言是一种值得我们尝试去使用的语言。关于协程和通道，后续会单独探讨这一重要特性。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><p>《Go语言编程》</p>
</li>
<li><p><a href="https://gobyexample.com/" target="_blank" rel="noopener">Go by Example</a></p>
</li>
</ul>
<div class="align-right"><span>2019-03-15 21:18</span><span> 创建</span></div><div class="align-right"><span>2020-03-15 17:29</span><span> 更新</span></div></div></div></body></html>